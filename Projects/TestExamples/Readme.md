## 程序说明(ISOC++11)
* 2_1.cpp 表现无符号整型的计算 
* 3_3.cpp 的 power(double x, int n)
* 4_2.cpp 使用了拷贝构造函数Point:
	关于函数返回值优化拷贝构造函数可参考：http://blog.sina.com.cn/s/blog_4ab8464c0100kybj.html
	友元函数：模拟反复使用私有成员（考虑到效率，不用get），这里用friend 
* 4_4.cpp 实参复制给形参的过程：从最后一个参数开始传 
* 4_8.cpp 实现了联合体，避免代码冗余和错误 
* 4_9.cpp 实现了枚举类，不同枚举类的属性不能做比较。Cfree增加C++11的支持，参考;https://blog.csdn.net/wallying/article/details/84546533 
* 4_10.cpp 实现了组合类的调用，要注意析构和构造函数的调用
* 6_10.cpp 变量地址作为实参，提高了传递的效率 
* 6_12.cpp 定义了函数指针int(*funcName)(int,int) 
* 6_18.cpp 动态创建多维数组 
* 6_19.cpp 动态数组封装成类 
* 6_22.cpp 浅层复制（空间复制一倍、数据复制一份）。复制的如果是地址，析构了第一个类之后，另外一个指针指向的地方没有对应空间，就会出现一直析构，出现死循环的情况。 
* 6_23.cpp 关于函数返回值是对象的情况，优化拷贝构造函数通过移动构造函数解决 
* 6_25.cpp 访问数组元素，既可以借助下标，也可以利用指针，通常利用下标 
* 7_3.cpp 虚函数使用 
* 8_1.cpp 双目运算符重载 
* 8_2.cpp 单目运算符重载
* 8_3.cpp 运算符重载为非成员函数，friend 

## 注意：
* 只有构造函数可以用:初始化
* 对象调用中：实参传递给形参，形参赋值给对象都会调用拷贝构造函数。
* 函数退出之后，会析构一次。最终return 0时把所有定义的对象给析构掉
* 整体的构造函数数量=析构函数的数量 
* static int 有全局寿命，看是否是局部可见 
* 关于引用传递：能保证参数传递中不产生副本，提高传递的效率；且通过const的使用，保证了引用传递的安全性 
* const是要用到类的成员函数上；const变量是要在构造函数的":"后面初始化，不能放到类体 
* 系统的头文件用<>括起来（到安装目录下），自己写的用""括起来（到当前目录找） 
* 在构造函数里，可以指定默认值，但是在外部定义的时候，不能再加，否则编译会出default parameter given for parameter

 ## 错误信息，增大排错效率 
 * 中文含义
 * 根本原因
 * 解决方法 